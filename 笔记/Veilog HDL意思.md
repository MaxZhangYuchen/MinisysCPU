# 常见单词意思

### 1. Design Sources 设计文件

    1. 指定HDL、网表

### 2. Constraints 约束文件

    1. 时间约束，管脚约束

### 3. Simulation Sources 仿真文件

### 4. Utility Source

### 5. RTL

描述数据在寄存器之间流动和如何处理这些数据的模型

#### 6. 程序综合

类似于编程中的编译

#### 7. bin

二进制文件，一般来讲是机器代码

# 字符类型

## reg

## wire

## memory

## parameter

常量标识



# 运算符

## 位运算符

## 缩减运算符



对单个操作数进行递推运算

先将操作数的最低为与第二位进行与、或、非运算，再将运算结果与第三位进行相同的运算，直到最高位

最后缩减为一位二进制数
## 移位运算符
+ ==>>== 右移
+ ==<<==  左移
+ 其他位补零

##  位拼接运算符

=={}==

用于将两个或多个信号的某些为拼接起来，表示成一个整体信号

用法{信号1的某几位，信号2的某几位，。。。，信号n的某几位}

例如：加法运算将和和进位拼接在一起

## 运算符优先级



# 语句

## 1. 连续赋值语句——assign语句

用于对wire型变量赋值

```
assign c = a & b; // a\b\c均为wire型变量
```

## 2. 过程赋值语句

==对reg型变量进行赋值==

### 1. 非阻塞赋值 b<=a

```
always @(posedge clk)
	begin
		b<=a;
		c<=b;  //块结束时才完成赋值操作，c的值比b的值落后一个周期
	end
```

### 2. 阻塞赋值 b=a

```
always @(posedge clk)
begin
	b=a;
	c=b;   //语句结束时就完成赋值操作，c与b的值相同
end
```

如果有多条语句，在前面赋值语句被完成之前，后面的语句就不能被执行

## 3. begin_end 顺序执行

### 前一条语句执行完才下一条

```
begin
	b = a;
	#10 c = a //延迟十秒再执行
end
```



## 4. fork_join 并行块

不可综合

块内语句同时执行

块内每条语句的延迟时间是相对于程序流程控制进入到块内的仿真时间决定的

通过控制延迟时间，实现延迟控制

```
reg[7:0]r;
fork
	#50 r = `h55;//延迟50
	#100 r = `hE2;//延迟100，
join
```

可不必按顺序给出，为了可读选择上种

```
reg[7:0]r;
fork
	#100 r = `hE2;//延迟100
	#50 r = `h55;//延迟50
join
```



## 5. initial结构说明语句：初始化语句，测试模块

+ 只执行一次
+ 不可综合，常用在测试文件中

在仿真的初始状态对各变量进行初始化

测试文件中生成激励波形作为仿真信号

## 6. always

+ 过程赋值语句

+ 块内顺序执行

+ 与assign是并行执行的  

#### 1. 包含一个或一个以上的声明语句，不断重复执行知道仿真结束，在定时控制下被反复执行。

在always块中被赋值的只能是寄存器型变量如reg、integer、real、time。

语句超过一条需要放在begin——end或fork——join语句中

```
always<时序控制><语句>
```

#### 2. 必须与一定的时序控制（@后的时序控制）结合在一起，没有控制容易形成仿真死锁。有时需要利用这种死锁。

例：生成一个零延迟的无限循环跳变过程

```
always areg = ~areg;
```

#### 3. 块语句模板

```
always @(<敏感信号表达式>)
	begin
	//过程赋值
	//if语句
	//case语句
	//while，repeat，for循环
	//task，function调用
	end
```

#### 4. 敏感信号表达式

1. 改变时，执行一次块内语句

2. 敏感信号表达式中应列出影响块内取值的所有信号

3. 可以为单个信号也可以为多个，中间用or链接

4. 不能为x和z否则或阻挡进程

#### 5. 沿触发，也可以为电平触发

==posedge==沿触发、==negedge==电平触发

#### 6. 为更好地综合可以用相关的结构语句

```
always@（Inputs）

​	begin

​	end
```

#### 7. 多个 if 可能造成一个驱动器有多个时钟驱动，编译错误

可能有多个if满足条件

```
always@(poseage min_clk or negedge reset)
	begin
	if(reset)
	min<=0;
	else if (min = )        //注意不能用if
```

## 7. task和function语句