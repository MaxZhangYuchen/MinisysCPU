# 在点阵上显示自己的名字

## 1. 16×16点阵上显示汉字的原理

使用256个发光二极管，组成16行16列的发光点阵。国际汉字库中的每一个字均有16行×16列的256点阵来表示。每个点为一个像素，每个字为一个图像。

工作原理与8位数码管类似。通过16个共阴极输出端口，每个共阴极对应16个LED显示灯，所以其扫描译码地址需要4位地址线，汉字扫描码由16位段地址输入，通过时钟对每列进行扫描，显示完整文字。

扫描三种方式：

1. 点扫描 ： 扫描频率要大于1024Hz
2. 行扫描：扫描频率大于128Hz
3. 列扫描：扫描频率大于128Hz

需要足够的扫描频率才能符合视觉暂留，形成完整图像

## 2. 框图

## 3. 实验需求

将自己的名字显示在点阵管上，每0.5秒刷新到下一个字

## 4. 程序分析

#### 1. 16×16点阵管实测

![image-20200702160431654](%E5%9C%A8%E7%82%B9%E9%98%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97.assets/image-20200702160431654.png)

Y轴，信号为1，这行灯管亮，信号为0，这行不亮

X轴，信号为0，这列灯光亮，信号为1，这列不亮

#### 2. 程序实现方法

1. 将需要的汉字的国标码转换成点阵信息
2. 通过memory存储需要字的点阵信息
3. 通过列刷新的方式，显示在点阵中

## 5. 相关资料

### [verilog语法之memory存储器](https://www.cnblogs.com/qidaiymm/p/5677305.html)

命名规则：reg[n-1:0] 存储器名[m-1:0]

说明：这是m个n位的存储器，该存储器的地址范围是0-（m-1）

举例：reg[3:0] memo[255:0]

说明：这是256个4位存储器，该存储器地址范围是0-255

赋值：memo[200] = 4'b1010;

说明：给第200地址单元赋值4'b1010；

精确到位：memo[56][2]

说明：第56地址的第2位数据

赋值：wire data=memo[56][1];

说明：把memo中第56地址的第1位数据赋值给data；

### memory使用方法

```
有一种存储器赋值的方法是分别对存储器中的每个字赋值。例如：

reg [0:3] Xrom [1:4]
. . .
Xrom[1] = 4'hA;
Xrom[2] = 4'h8;
Xrom[3] = 4'hF;
Xrom[4] = 4'h2;

为存储器赋值的另一种方法是使用系统任务：
　　1) $readmemb （加载二进制值）
　　2) $readmemb （加载十六进制值）
　　这些系统任务从指定的文本文件中读取数据并加载到存储器。文本文件必须包含相应的二进制或者十六进制数。例如：

reg [1:4] RomB [7:1] ;
$ readmemb ("ram.patt", RomB);

Romb是存储器。文件“ram.patt”必须包含二进制值。文件也可以包含空白空间和注释。下面是文件中可能内容的实例。

1101
1110
1000
0111
0000
1001
0011

　　系统任务$readmemb促使从索引7即Romb最左边的字索引，开始读取值。如果只加载存储器的一部分，值域可以在$readmemb方法中显式定义。例如：

$readmemb ("ram.patt", RomB, 5, 3);

在这种情况下只有Romb[5],Romb[4]和Romb[3]这些字从文件头开始被读取。被读取的值为1101、1100和1000。
文件可以包含显式的地址形式。

@hex_address value
如下实例：
@5 11001
@2 11010

在这种情况下，值被读入存储器指定的地址。
　　当只定义开始值时，连续读取直至到达存储器右端索引边界。例如：

$readmemb ("rom.patt", RomB, 6);
//从地址6开始，并且持续到1。
$readmemb ( "rom.patt", RomB, 6, 4);
//从地址6读到地址4。
```

## 6.实验过程记录

### 1. memory语句必须在过程语句中赋值，需要在always中，在assign中是不行的

   + 错误截图

     ![image-20200702221425207](%E5%9C%A8%E7%82%B9%E9%98%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97.assets/image-20200702221425207.png)

   + 正确截图

![image-20200702221603987](%E5%9C%A8%E7%82%B9%E9%98%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97.assets/image-20200702221603987.png)

### 2. 第一次代码

        Column = Column / 2;
            case(Column)   //列为零，行为1显示
                1:Row <= 16'b1000_0111_1000_0000;
                16'b1011_1111_1111_1111:Row <= 16'b1000_0100_1000_0000;
                16'b1101_1111_1111_1111:Row <= 16'b1000_0100_1000_0000;
                16'b1110_1111_1111_1111:Row <= 16'b1000_0100_1000_0000; //前4列的行显示情况
                16'b1111_0111_1111_1111:Row <= 16'b1000_0100_1000_0100;
                16'b1111_1011_1111_1111:Row <= 16'b1000_0100_1000_0010;
                16'b1111_1101_1111_1111:Row <= 16'b1111_1100_1111_1111;
                16'b1111_1110_1111_1111:Row <= 16'b1000_0010_0000_0000;//5-8显示情况
                16'b1111_1111_0111_1111:Row <= 16'b1111_1111_1111_1111;
                16'b1111_1111_1011_1111:Row <= 16'b0000_0111_0000_0010;
                16'b1111_1111_1101_1111:Row <= 16'b0000_1010_1000_0100;
                16'b1111_1111_1110_1111:Row <= 16'b0001_0010_1000_0000;//9-12
                16'b1111_1111_1111_0111:Row <= 16'b0010_0010_0010_0000;
                16'b1111_1111_1111_1011:Row <= 16'b0100_0010_0001_0000;
                16'b1111_1111_1111_1101:Row <= 16'b1000_0010_0000_1000;
                16'b1111_1111_1111_1110:Row <= 16'b0000_0101_0000_0100;//13-16
![image-20200704093413740](%E5%9C%A8%E7%82%B9%E9%98%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97.assets/image-20200704093413740.png)

推测还是信号的输出有问题，赋值的列显示信息是反的1111_1111_1111_1110对应是第一行输出

### 3. 改进设计，将case中的判定条件改为具体的行数，输出对应的点阵信息

```
module display_decode(
    output [15:0] Column,  //列
    output [15:0]Row,
    input clk
    ); 
    reg[15:0] Row;
    reg [15:0] Column;
    integer i= 1;
    always@(posedge clk)        
        begin
        i = i + 1;
            case(i)   //列为零，行为1显示
                1:Row <= 16'b1000_0111_1000_0000;
                2:Row <= 16'b1000_0100_1000_0000;
                3:Row <= 16'b1000_0100_1000_0000;
                4:Row <= 16'b1000_0100_1000_0000; //前4列的行显示情况
                5:Row <= 16'b1000_0100_1000_0100;
                6:Row <= 16'b1000_0100_1000_0010;
                7:Row <= 16'b1111_1100_1111_1111;
                8:Row <= 16'b1000_0010_0000_0000;//5-8显示情况
                9:Row <= 16'b1111_1111_1111_1111;
                10:Row <= 16'b0000_0111_0000_0010;
                11:Row <= 16'b0000_1010_1000_0100;
                12:Row <= 16'b0001_0010_1000_0000;//9-12
                13:Row <= 16'b0010_0010_0010_0000;
                14:Row <= 16'b0100_0010_0001_0000;
                15:Row <= 16'b1000_0010_0000_1000;
                16:Row <= 16'b0000_0101_0000_0100;//13-16
            endcase
            case(i)
                1:Column <= 16'b1111_1111_1111_1110;
                2:Column <= 16'b1111_1111_1111_1101;
                3:Column <= 16'b1111_1111_1111_1011;
                4:Column <= 16'b1111_1111_1111_0111; //前4列的行显示情况
                5:Column <= 16'b1111_1111_1110_1111;
                6:Column <= 16'b1111_1111_1101_1111;
                7:Column <= 16'b1111_1111_1011_1111;
                8:Column <= 16'b1111_1111_0111_1111;//5-8显示情况
                9:Column <=  16'b1111_1110_1111_1111;
                10:Column <= 16'b1111_1101_1111_1111;
                11:Column <= 16'b1111_1011_1111_1111;
                12:Column <= 16'b1111_0111_1111_1111;//9-12
                13:Column <= 16'b1110_1111_1111_1111;
                14:Column <= 16'b1101_1111_1111_1111;
                15:Column <= 16'b1011_1111_1111_1111;
                16:Column <= 16'b0111_1111_1111_1111;//13-16
                endcase
                if(i==16)
                    i=1;
      end
endmodule

```

输出的字是反的，说明Row信号给的是反的，点阵信息，最下面是第一个，最上面是一列中的最后一个。将给出的点阵信号进行对称，如下版代码所示字中有些点缺失需要调整，将i+1放在了begin的第一句话导致没有第一列显示

![image-20200704100857908](%E5%9C%A8%E7%82%B9%E9%98%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97.assets/image-20200704100857908.png)

### 4. 再改进版——完成第一个字的输出

成功输出“张”字

```
module display_decode(
    output [15:0] Column,  //列
    output [15:0]Row,
    input clk
    ); 
    reg [15:0] Column;  //点阵中哪一列亮
    reg[15:0] Row; //一列中的哪一排亮
    integer i= 1;
    always@(posedge clk)        //一个时钟刷新一行 时钟越快刷新速度越快
        begin
            case(i)   //每列显示的点阵信息
                1:Row <= 16'b0000_0001_1110_0001;
                2:Row <= 16'b0000_0001_0010_0001;
                3:Row <= 16'b0000_0001_0010_0001;
                4:Row <= 16'b0000_0001_0010_0001; //前4列的行显示情况
                5:Row <= 16'b0010_0001_0010_0001;
                6:Row <= 16'b0100_0001_0010_0001;
                7:Row <= 16'b1111_1111_0011_1111;
                8:Row <= 16'b0000_0000_0100_0000;//5-8显示情况
                9:Row <= 16'b1111_1111_1111_1111;
                10:Row <= 16'b0100_0000_1110_0000;
                11:Row <= 16'b0010_0001_0101_0000;
                12:Row <= 16'b0000_0010_0100_1000;//9-12
                13:Row <= 16'b0000_0100_0100_0100;
                14:Row <= 16'b0000_1000_0100_0010;
                15:Row <= 16'b0001_0000_0100_0001;
                16:Row <= 16'b0010_0000_0000_0000;//13-16
            endcase
            case(i)            //列刷新的方式，每次前进一列
                1:Column <= 16'b1111_1111_1111_1110;
                2:Column <= 16'b1111_1111_1111_1101;
                3:Column <= 16'b1111_1111_1111_1011;
                4:Column <= 16'b1111_1111_1111_0111; //前4列的行显示情况
                5:Column <= 16'b1111_1111_1110_1111;
                6:Column <= 16'b1111_1111_1101_1111;
                7:Column <= 16'b1111_1111_1011_1111;
                8:Column <= 16'b1111_1111_0111_1111;//5-8显示情况
                9:Column <=  16'b1111_1110_1111_1111;
                10:Column <= 16'b1111_1101_1111_1111;
                11:Column <= 16'b1111_1011_1111_1111;
                12:Column <= 16'b1111_0111_1111_1111;//9-12
                13:Column <= 16'b1110_1111_1111_1111;
                14:Column <= 16'b1101_1111_1111_1111;
                15:Column <= 16'b1011_1111_1111_1111;
                16:Column <= 16'b0111_1111_1111_1111;//13-16
                endcase
                i = i + 1;
                if(i==17)
                    i=1;

      end
endmodule
```

![image-20200704105932694](%E5%9C%A8%E7%82%B9%E9%98%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97.assets/image-20200704105932694.png)

### 5. 同理输入后两个字的点阵信息

每个字的 Column相同，调整Row

“宇”

```
case(i)
                1:Row <= 16'b0000_0000_0000_0000;
                2:Row <= 16'b0000_0000_0000_0000;
                3:Row <= 16'b0000_0010_0011_0000;
                4:Row <= 16'b0000_0010_0001_0000;
                5:Row <= 16'b0000_0010_0001_0000;
                6:Row <= 16'b0010_0010_0101_0000;
                7:Row <= 16'b0100_0010_0101_0010;
                8:Row <= 16'b0111_1111_1101_0100;
                9:Row <= 16'b0000_0010_0101_1000;
                10:Row <= 16'b0000_0010_0101_0000;
                11:Row <= 16'b0000_0010_0001_0000;
                12:Row <= 16'b0000_0010_0001_0000;	
                13:Row <= 16'b0000_0010_0011_0000;
                14:Row <= 16'b0000_0000_0001_0000;	
                15:Row <= 16'b0000_0000_0000_0000;
                16:Row <= 16'b0000_0000_0000_0000;
endcase
```

“辰”

```
				1:Row <= 16'b0000_0000_0000_0000;
                2:Row <= 16'b0001_0000_0000_0000;
                3:Row <= 16'b0000_1000_0000_0000;
                4:Row <= 16'b0000_0100_0000_0000;
                5:Row <= 16'b0000_0011_0000_0000;
                6:Row <= 16'b1111_1111_1111_1110;
                7:Row <= 16'b0100_0001_1001_0010;
                8:Row <= 16'b0010_0010_1001_0010;
                9:Row <= 16'b0000_0100_1001_0010;
                10:Row <= 16'b0000_1000_1001_0010;
                11:Row <= 16'b0001_0000_1000_0010;
                12:Row <= 16'b0010_0000_0000_0000;	
                13:Row <= 16'b0010_0000_0000_0000;
                14:Row <= 16'b0000_0000_0000_0000;	
                15:Row <= 16'b0000_0000_0000_0000;
                16:Row <= 16'b0000_0000_0000_0000;
```

### 6. 通过时序实现每0.5秒换一个字

#### 代码部分

Column决定哪一列显示，“0”为该列显示，“1”为该列不显示

Row决定哪一行显示，“1”为该行显示，“0”为该行不显示

Column和Row均是左下角为第一位点阵信息。

采用列刷新的方法

远程平台中，Column接16×16的底下的管脚，Row接左侧管脚

通过对于运行次数的计数，实现0.5秒的汉字切换，在代码中记为t。

每一个时钟运行一次always语句。

代码中使用10Hz的时钟频率，执行5000次always语句中的内容为0.5秒，在always中添加条件语句，每5000次换一个字。

```
module display_decode(
    output [15:0] Column,  //列
    output [15:0]Row,
    input clk
    ); 
    reg [15:0] Column;  //点阵中哪一列亮
    reg[15:0] Row; //一列中的哪一排亮
    integer i= 0;//列的循环的标记
    integer t = 1;//always块的运行次数标记
    always@(posedge clk)        //一个时钟刷新一行 时钟越快刷新速度越快
        begin
        case(i)            //列刷新的方式，每次前进一列 不管是哪个字都需要进行列刷新
                0:Column <= 16'b1111_1111_1111_1110;
                1:Column <= 16'b1111_1111_1111_1101;
                2:Column <= 16'b1111_1111_1111_1011;
                3:Column <= 16'b1111_1111_1111_0111; //前4列的行显示情况
                4:Column <= 16'b1111_1111_1110_1111;
                5:Column <= 16'b1111_1111_1101_1111;
                6:Column <= 16'b1111_1111_1011_1111;
                7:Column <= 16'b1111_1111_0111_1111;//5-8显示情况
                8:Column <=  16'b1111_1110_1111_1111;
                9:Column <= 16'b1111_1101_1111_1111;
                10:Column <= 16'b1111_1011_1111_1111;
                11:Column <= 16'b1111_0111_1111_1111;//9-12
                12:Column <= 16'b1110_1111_1111_1111;
                13:Column <= 16'b1101_1111_1111_1111;
                14:Column <= 16'b1011_1111_1111_1111;
                15:Column <= 16'b0111_1111_1111_1111;//13-16
            endcase
            if(t <= 5000)    //张字
            begin
                case(i)   //每列显示的点阵信息
                0:Row <= 16'b0010_0000_0000_0010;
                1:Row <= 16'b0100_0011_1110_0010;
                2:Row <= 16'b1000_0010_0010_0010;
                3:Row <= 16'b0100_0010_0010_0010; //前4列的行显示情况
                4:Row <= 16'b0011_1110_0011_1111;
                5:Row <= 16'b0000_0000_0100_0010;
                6:Row <= 16'b0000_0000_0100_0000;
                7:Row <= 16'b1111_1111_1111_1111;//5-8显示情况
                8:Row <= 16'b1000_0000_0100_0000;
                9:Row <= 16'b0100_0001_1101_0000;
                10:Row <= 16'b0000_1100_0100_1000;
                11:Row <= 16'b0001_0010_0100_0100;//9-12
                12:Row <= 16'b0010_0000_0100_0110;
                13:Row <= 16'b0110_0000_0110_0000;
                14:Row <= 16'b0010_0000_0100_0000;
                15:Row <= 16'b0000_0000_0000_0000;//13-16
                endcase
                t = t+1;
            end
            else if(t>5000 && t<=10000)   //宇字
                begin
                case(i)
                0:Row <= 16'b0000_0000_0001_0000;
                1:Row <= 16'b0000_0001_0000_1100;
                2:Row <= 16'b0000_0001_0000_0100;
                3:Row <= 16'b0000_0001_0010_0100;
                4:Row <= 16'b0000_0001_0010_0100;
                5:Row <= 16'b0100_0001_0010_0100;
                6:Row <= 16'b1000_0001_0010_0101;
                7:Row <= 16'b0111_1111_1110_0110;
                8:Row <= 16'b0000_0001_0010_0100;
                9:Row <= 16'b0000_0001_0010_0100;
                10:Row <= 16'b0000_0001_0010_0100;
                11:Row <= 16'b0000_0001_0010_0100;	
                12:Row <= 16'b0000_0011_0000_0100;
                13:Row <= 16'b0000_0001_0001_0100;	
                14:Row <= 16'b0000_0000_0000_1100;
                15:Row <= 16'b0000_0000_0000_0000;
                endcase
                t = t + 1;
            end
            else if(t>10000 && t<=15000)  //辰
                begin
                case(i)
                0:Row <= 16'b0100_0000_0000_0000;
                1:Row <= 16'b0011_0000_0000_0000;
                2:Row <= 16'b0000_1111_1111_1110;
                3:Row <= 16'b0000_0000_1001_0010;
                4:Row <= 16'b0000_0000_1001_0010;
                5:Row <= 16'b1000_0000_1001_0010;
                6:Row <= 16'b1111_1111_1001_0010;
                7:Row <= 16'b0010_0011_1001_0010;
                8:Row <= 16'b0000_0100_1001_0010;
                9:Row <= 16'b0000_1000_1001_0010;
                10:Row <= 16'b0001_0100_1001_1010;
                11:Row <= 16'b0001_0010_1001_0011;	
                12:Row <= 16'b0010_0000_1100_0010;
                13:Row <= 16'b0110_0000_1000_0000;	
                14:Row <= 16'b0010_0000_0000_0000;
                15:Row <= 16'b0000_0000_0000_0000;
                endcase
                t = t + 1;
            end
                i = i + 1;
                if(i==16) i = 0;
           else if(t>15000) t=1;
           
      end
endmodule
```

最终效果

![image-20200705222807409](%E5%9C%A8%E7%82%B9%E9%98%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97.assets/image-20200705222807409.png)

![image-20200705222823754](%E5%9C%A8%E7%82%B9%E9%98%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97.assets/image-20200705222823754.png)

![image-20200705222833046](%E5%9C%A8%E7%82%B9%E9%98%B5%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8D%E5%AD%97.assets/image-20200705222833046.png)

## 7. bin文件在文件夹中